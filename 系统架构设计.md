# 企业知识库客服助理 - 系统架构设计

## 1. 总体架构

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Vue 前端      │───▶│   Java API       │───▶│  Python RAG     │
│  - 对话界面     │    │   Spring Boot    │    │  Orchestrator   │
│  - 文档管理     │    │  - 用户认证      │    │  - 向量检索     │
│  - 工单管理     │    │  - 权限管理      │    │  - LLM调用      │
│  - 系统配置     │    │  - 多租户        │    │  - FunctionCall │
└─────────────────┘    │  - 计费          │    └─────────────────┘
                       │  - SSO集成       │            │
                       └──────────────────┘            │
                                │                       │
                       ┌──────────────────┐    ┌─────────────────┐
                       │   数据库层       │    │   向量数据库    │
                       │  - PostgreSQL    │    │  - Milvus       │
                       │  - Redis缓存     │    │  - FAISS        │
                       └──────────────────┘    └─────────────────┘
                                │
                       ┌──────────────────┐
                       │   外部服务       │
                       │  - Jira API      │
                       │  - CRM系统       │
                       │  - 邮件服务      │
                       │  - 文件存储      │
                       └──────────────────┘
```

## 2. 技术栈选型

### 2.1 前端 (Vue.js)
- **Vue 3** + TypeScript
- **Element Plus** - 企业级UI组件库
- **Vite** - 构建工具
- **Pinia** - 状态管理
- **Vue Router** - 路由管理
- **Axios** - HTTP客户端

### 2.2 后端 Java (Spring Boot)
- **Spring Boot 3.x**
- **Spring Security** - 认证授权
- **Spring Data JPA** - 数据访问
- **Spring Cloud Gateway** - API网关
- **Redis** - 缓存和会话
- **PostgreSQL** - 主数据库
- **JWT** - 令牌认证
- **OAuth2/SAML** - SSO集成

### 2.3 Python RAG引擎
- **FastAPI** - API框架
- **LangChain** - LLM编排
- **Sentence Transformers** - 文本嵌入
- **Milvus/FAISS** - 向量数据库
- **OpenAI/Claude API** - 大语言模型
- **Celery** - 异步任务队列

### 2.4 基础设施
- **Docker** - 容器化
- **Kubernetes** - 容器编排
- **Nginx** - 反向代理
- **MinIO** - 对象存储
- **ELK Stack** - 日志监控

## 3. 核心模块设计

### 3.1 用户认证与权限模块
```java
@Entity
public class Tenant {
    private String id;
    private String name;
    private String domain;
    private SubscriptionPlan plan;
    private Map<String, Object> settings;
}

@Entity 
public class User {
    private String id;
    private String tenantId;
    private String email;
    private Set<Role> roles;
    private boolean ssoEnabled;
}
```

### 3.2 文档管理模块
```java
@Entity
public class Document {
    private String id;
    private String tenantId;
    private String fileName;
    private String fileUrl;
    private DocumentStatus status;
    private Map<String, Object> metadata;
    private List<DocumentChunk> chunks;
}

@Entity
public class DocumentChunk {
    private String id;
    private String documentId;
    private String content;
    private String vectorId; // 向量数据库中的ID
    private Map<String, Object> metadata;
}
```

### 3.3 对话管理模块
```java
@Entity
public class Conversation {
    private String id;
    private String tenantId;
    private String userId;
    private String title;
    private List<Message> messages;
    private ConversationStatus status;
}

@Entity
public class Message {
    private String id;
    private String conversationId;
    private MessageRole role; // USER, ASSISTANT, SYSTEM
    private String content;
    private List<DocumentReference> sources;
    private List<FunctionCall> functionCalls;
}
```

### 3.4 工具集成模块
```java
@Entity
public class ToolConfiguration {
    private String id;
    private String tenantId;
    private ToolType type; // JIRA, CRM, EMAIL
    private Map<String, String> credentials;
    private boolean enabled;
}

@Entity
public class ToolExecution {
    private String id;
    private String tenantId;
    private String toolName;
    private Map<String, Object> parameters;
    private ExecutionStatus status;
    private String result;
}
```

## 4. 计费与订阅模块

### 4.1 订阅计划
```java
@Entity
public class SubscriptionPlan {
    private String id;
    private String name;
    private BigDecimal monthlyPrice;
    private PlanLimits limits;
}

@Data
public class PlanLimits {
    private int maxUsers;
    private long maxStorageGB;
    private int maxApiCalls;
    private int maxDocuments;
    private boolean advancedFeatures;
}
```

### 4.2 使用统计
```java
@Entity
public class UsageRecord {
    private String id;
    private String tenantId;
    private UsageType type; // API_CALL, STORAGE, VECTOR_SEARCH
    private long quantity;
    private LocalDateTime timestamp;
    private Map<String, Object> metadata;
}
```

## 5. Python RAG引擎架构

### 5.1 核心组件
```python
class RAGOrchestrator:
    def __init__(self):
        self.embedder = SentenceTransformer('model')
        self.vector_store = MilvusClient()
        self.llm_client = OpenAIClient()
        self.function_registry = FunctionRegistry()
    
    async def process_query(self, query: str, tenant_id: str) -> Response:
        # 1. 向量检索
        relevant_docs = await self.retrieve_documents(query, tenant_id)
        
        # 2. 构建prompt
        prompt = self.build_rag_prompt(query, relevant_docs)
        
        # 3. LLM调用
        response = await self.llm_client.chat_completion(
            prompt, 
            functions=self.get_available_functions(tenant_id)
        )
        
        # 4. 执行function calls
        if response.function_calls:
            for fc in response.function_calls:
                result = await self.execute_function(fc, tenant_id)
                response.add_function_result(result)
        
        return response
```

### 5.2 Function Call注册机制
```python
class FunctionRegistry:
    def __init__(self):
        self.functions = {}
    
    def register(self, name: str, handler: Callable, schema: dict):
        self.functions[name] = {
            'handler': handler,
            'schema': schema
        }
    
    async def execute(self, name: str, params: dict, context: dict):
        if name not in self.functions:
            raise FunctionNotFoundError(name)
        
        handler = self.functions[name]['handler']
        return await handler(params, context)

# 注册Jira工具
@function_registry.register('jira.createIssue', JIRA_CREATE_SCHEMA)
async def create_jira_issue(params: dict, context: dict):
    client = JiraClient(context['tenant_config'])
    return await client.create_issue(**params)
```

## 6. 数据流设计

### 6.1 文档上传流程
1. 前端上传文件到Java后端
2. Java验证文件格式和权限
3. 文件存储到MinIO
4. 异步调用Python进行文档处理
5. Python提取文本、分块、生成嵌入
6. 向量存储到Milvus
7. 更新文档状态

### 6.2 对话查询流程
1. 前端发送查询到Java API
2. Java验证权限和限额
3. 转发查询到Python RAG引擎
4. Python执行向量检索
5. 调用LLM生成回答
6. 执行必要的Function Calls
7. 返回结果到前端

## 7. 安全性设计

### 7.1 认证授权
- JWT令牌认证
- 基于角色的访问控制(RBAC)
- 多租户数据隔离
- API限流和防护

### 7.2 数据安全
- 传输层TLS加密
- 敏感数据库字段加密
- 审计日志记录
- 数据备份策略

## 8. 监控与运维

### 8.1 监控指标
- API响应时间和成功率
- 向量检索性能
- LLM调用统计
- 系统资源使用率
- 用户活跃度

### 8.2 日志管理
- 结构化日志格式
- 集中化日志收集
- 实时告警机制
- 日志分析报表

## 9. 部署架构

### 9.1 生产环境
```yaml
# docker-compose.yml
version: '3.8'
services:
  nginx:
    image: nginx:alpine
    ports: ["80:80", "443:443"]
    
  java-api:
    build: ./java-api
    replicas: 3
    
  python-rag:
    build: ./python-rag
    replicas: 2
    
  postgres:
    image: postgres:14
    
  redis:
    image: redis:alpine
    
  milvus:
    image: milvusdb/milvus:latest
```

### 9.2 扩展性考虑
- 微服务拆分策略
- 数据库读写分离
- 缓存层优化
- CDN加速
- 负载均衡

这个架构设计确保了系统的可扩展性、安全性和高可用性，同时满足企业级应用的要求。